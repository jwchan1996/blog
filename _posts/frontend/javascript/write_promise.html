<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>手写实现一个 Promise | 飘香豆腐の博客</title>
    <meta name="generator" content="VuePress 1.5.1">
    
    <meta name="description" content="记录技术与生活">
    <link rel="preload" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/css/0.styles.a02d1e66.css" as="style"><link rel="preload" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/app.81246855.js" as="script"><link rel="preload" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/2.905a7cdf.js" as="script"><link rel="preload" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/47.ac5420cb.js" as="script"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/10.59c68b4a.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/11.74f40a18.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/12.7b5efc90.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/13.5403caf6.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/14.7cada723.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/15.cbdfd995.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/16.3d4dc8dc.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/17.eb2babef.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/18.3bb92fea.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/19.f9a4adda.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/20.497c0353.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/21.00b1a3da.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/22.cd4b12e0.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/23.1e09cdf5.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/24.cb7c17c1.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/25.9590430f.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/26.e381fdd0.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/27.1451eca1.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/28.3337ec87.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/29.97d39157.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/3.916bd0f8.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/30.c15c526e.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/31.809a7f24.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/32.2c452435.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/33.8b3924f3.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/34.1a7193f7.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/35.7029d4bb.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/36.c85e43b4.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/37.f0e096a4.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/38.6ea69547.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/39.8fc51db1.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/4.97f3f9a9.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/40.e91a4b10.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/41.4efb9087.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/42.ff2c802b.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/43.04dcaf83.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/44.f4162521.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/45.c64c3af0.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/46.f0352e8e.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/48.6e061d1b.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/49.eb44290d.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/5.e566d2f3.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/50.f3b69ef8.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/51.87199ed8.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/52.12d1e0da.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/53.379c0ab7.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/54.2ac120ed.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/55.e45829f7.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/56.682cd943.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/57.6d656502.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/58.2a0d4f47.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/59.3f91e679.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/6.d73d86c1.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/60.ff60501a.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/61.26849ec9.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/62.2c936095.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/63.284a0309.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/64.6f3cf823.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/65.58e471b9.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/66.6f64edc3.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/67.a1e83ed4.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/68.feac9ee6.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/69.241391a0.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/7.fc52c0a5.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/70.bd1454a6.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/71.4aab9aaa.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/72.6f93b182.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/73.fb0638d0.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/74.2ee71f28.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/75.247a33f5.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/76.7bbaf4b8.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/8.203f3966.js"><link rel="prefetch" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/9.dd9b807f.js">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/css/0.styles.a02d1e66.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="飘香豆腐の博客" class="logo"> <span class="site-name can-hide">飘香豆腐の博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/frontend/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-subitem"><a href="/_posts/frontend/react/" class="nav-link">
  react
</a></li><li class="dropdown-subitem"><a href="/_posts/frontend/javascript/" class="nav-link router-link-active">
  javascript
</a></li><li class="dropdown-subitem"><a href="/_posts/frontend/typescript/" class="nav-link">
  typescript
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/backend/node/" class="nav-link">
  node
</a></li><li class="dropdown-subitem"><a href="/_posts/backend/deno/" class="nav-link">
  deno
</a></li><li class="dropdown-subitem"><a href="/_posts/backend/go/" class="nav-link">
  go
</a></li><li class="dropdown-subitem"><a href="/_posts/backend/rust/" class="nav-link">
  rust
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/tool/docker/" class="nav-link">
  docker
</a></li><li class="dropdown-subitem"><a href="/_posts/tool/git/" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/_posts/tool/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-subitem"><a href="/_posts/tool/rollup/" class="nav-link">
  rollup
</a></li></ul></li><li class="dropdown-item"><h4>
          跨端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/across/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-subitem"><a href="/_posts/across/electron/" class="nav-link">
  electron
</a></li></ul></li><li class="dropdown-item"><h4>
          第三方库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/plugin/axios/" class="nav-link">
  axios
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/other/" class="nav-link">
  未分类
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/jwchan1996/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  主页
</a></div><div class="nav-item"><a href="/archives/" class="nav-link">
  归档
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="分类" class="dropdown-title"><span class="title">分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          前端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/frontend/vue/" class="nav-link">
  vue
</a></li><li class="dropdown-subitem"><a href="/_posts/frontend/react/" class="nav-link">
  react
</a></li><li class="dropdown-subitem"><a href="/_posts/frontend/javascript/" class="nav-link router-link-active">
  javascript
</a></li><li class="dropdown-subitem"><a href="/_posts/frontend/typescript/" class="nav-link">
  typescript
</a></li></ul></li><li class="dropdown-item"><h4>
          后端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/backend/node/" class="nav-link">
  node
</a></li><li class="dropdown-subitem"><a href="/_posts/backend/deno/" class="nav-link">
  deno
</a></li><li class="dropdown-subitem"><a href="/_posts/backend/go/" class="nav-link">
  go
</a></li><li class="dropdown-subitem"><a href="/_posts/backend/rust/" class="nav-link">
  rust
</a></li></ul></li><li class="dropdown-item"><h4>
          工具
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/tool/docker/" class="nav-link">
  docker
</a></li><li class="dropdown-subitem"><a href="/_posts/tool/git/" class="nav-link">
  git
</a></li><li class="dropdown-subitem"><a href="/_posts/tool/webpack/" class="nav-link">
  webpack
</a></li><li class="dropdown-subitem"><a href="/_posts/tool/rollup/" class="nav-link">
  rollup
</a></li></ul></li><li class="dropdown-item"><h4>
          跨端
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/across/flutter/" class="nav-link">
  flutter
</a></li><li class="dropdown-subitem"><a href="/_posts/across/electron/" class="nav-link">
  electron
</a></li></ul></li><li class="dropdown-item"><h4>
          第三方库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/plugin/axios/" class="nav-link">
  axios
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/_posts/other/" class="nav-link">
  未分类
</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div><div class="nav-item"><a href="https://github.com/jwchan1996/blog" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>JavaScript</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/_posts/frontend/javascript/js_call_apply_bind.html" class="sidebar-link">JavaScript 中的 call()、apply()、bind() 的用法</a></li><li><a href="/_posts/frontend/javascript/js_simulate_call_apply_bind.html" class="sidebar-link">JS 模拟实现 call、apply、bind</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/js_simulate_call_apply_bind.html#实现call" class="sidebar-link">实现call</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/js_simulate_call_apply_bind.html#实现apply" class="sidebar-link">实现apply</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/js_simulate_call_apply_bind.html#实现bind" class="sidebar-link">实现bind</a></li></ul></li><li><a href="/_posts/frontend/javascript/publish_subscribe_observer.html" class="sidebar-link">发布订阅模式和观察者模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/publish_subscribe_observer.html#发布-订阅模式" class="sidebar-link">发布/订阅模式</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/publish_subscribe_observer.html#观察者模式" class="sidebar-link">观察者模式</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/publish_subscribe_observer.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/_posts/frontend/javascript/write_promise.html" aria-current="page" class="active sidebar-link">手写实现一个 Promise</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#关于-promsie" class="sidebar-link">关于 Promsie</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#实现一个简单-promise-类" class="sidebar-link">实现一个简单 Promise 类</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#promise-类中处理异步逻辑" class="sidebar-link">Promise 类中处理异步逻辑</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#实现-then-方法多次调用" class="sidebar-link">实现 then 方法多次调用</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#实现-then-方法的链式调用" class="sidebar-link">实现 then 方法的链式调用</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#then-方法链式调用识别-promise-对象自返回" class="sidebar-link">then 方法链式调用识别 Promise 对象自返回</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#捕获错误" class="sidebar-link">捕获错误</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#将-then-方法的参数变成可选参数" class="sidebar-link">将 then 方法的参数变成可选参数</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#promise-all-方法的实现" class="sidebar-link">Promise.all 方法的实现</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#promise-race-方法的实现" class="sidebar-link">Promise.race 方法的实现</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#promise-resolve-方法的实现" class="sidebar-link">Promise.resolve 方法的实现</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#finally-方法的实现" class="sidebar-link">finally 方法的实现</a></li><li class="sidebar-sub-header"><a href="/_posts/frontend/javascript/write_promise.html#catch-方法的实现" class="sidebar-link">catch 方法的实现</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="手写实现一个-promise"><a href="#手写实现一个-promise" class="header-anchor">#</a> 手写实现一个 Promise</h1> <h2 id="关于-promsie"><a href="#关于-promsie" class="header-anchor">#</a> 关于 Promsie</h2> <p>下面是实现一个 <code>Promise</code> 的一些关键点：</p> <ul><li><code>Promise</code> 是一个类，在执行这个类的时候，需要传递一个执行器（<code>executor</code>）进去，执行器会立即执行。</li> <li><code>Promise</code> 中有三种状态，分别为成功（<code>fulfilled</code>）、失败（<code>rejected</code>）和等待（<code>pending</code>）。其中 <code>pending</code> 状态会变为 <code>fulfilled</code> 或者 <code>rejected</code>，且一旦状态确定就不可以更改。</li> <li><code>resolve</code> 和 <code>reject</code> 函数是用来改变状态的： <code>resolve -&gt; fulfilled</code>、<code>reject -&gt; rejected</code>。</li> <li><code>then</code> 方法内部做的事情就是判断状态。如果状态是成功，调用成功的回调函数。如果状态是失败，调用失败的回调函数。每一个 <code>Promise</code> 对象都能够调用 <code>then</code> 方法，<code>then</code> 方法是被定义在原型对象中的。</li> <li><code>then</code> 的成功回调函数有一个参数，表示成功之后的值。<code>then</code> 的 失败回调函数也有一个参数，表示失败后的原因。</li></ul> <p><code>Promise</code> 的基本用法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
    <span class="token comment">//reject('失败')</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="实现一个简单-promise-类"><a href="#实现一个简单-promise-类" class="header-anchor">#</a> 实现一个简单 Promise 类</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>   <span class="token comment">// 等待</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>   <span class="token comment">// 成功</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span>     <span class="token comment">// 失败</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 传入一个执行器并立即执行（执行器两个参数是函数）</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// promise 状态初始值</span>
    status <span class="token operator">=</span> <span class="token constant">PENDING</span>
    <span class="token comment">// promise 成功 resolve 传递的值（默认值）</span>
    value <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">// promise 失败 reject 传递的原因（默认值）</span>
    reason <span class="token operator">=</span> <span class="token keyword">undefined</span>
    
    <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为成功</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>
        <span class="token comment">// 保存 promise 成功传过来的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value 
    <span class="token punctuation">}</span>
    
    <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为失败</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span>
        <span class="token comment">// 保存 promise 失败传过来的原因</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason 
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 类的所有方法都是定义在类的 prototype 属性上面的</span>
    <span class="token comment">// 即类的方法是被定义在原型对象中的，此处 then 方法就是</span>
    <span class="token comment">// then 方法期望的参数是回调函数</span>
    <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断状态</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="promise-类中处理异步逻辑"><a href="#promise-类中处理异步逻辑" class="header-anchor">#</a> Promise 类中处理异步逻辑</h2> <p>假设在我们在 <code>MyPromise</code> 类实例对象的执行器中执行异步任务 <code>setTimeout</code>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
    <span class="token comment">//reject('失败')</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>代码的执行顺序是从上到下依次执行的，在创建 <code>MyPromsie</code> 类实例对象后，执行器会立即执行。在执行器代码执行过程中，发现 <code>setTimeout</code> 是异步任务，那么代码执行主线程会在开启这个异步任务后会立即往下执行，不会等待异步任务的完成，所以会立即往下执行 <code>then</code> 方法。</p> <p>但是，由于此时还没有发生状态改变，<code>MyPromise</code> 实例对象的状态还是处于 <code>pending</code> 状态，因此我们要在 <code>then</code> 方法内对 <code>pending</code> 这种状态进行处理（因为 <code>then</code> 方法 只执行一次，等异步任务结束后 <code>Promise</code> 状态改变已经不会再执行这一次的 <code>then</code> 方法了）。</p> <p>异步耗时任务结束后会调用 <code>resolve</code> 或者 <code>reject</code> 方法，因此我们还需要在 <code>MyPromise</code> 类的 <code>resolve</code> 属性方法和 <code>reject</code> 属性方法内调用定义在 <code>then</code> 方法内的成功回调函数和失败回调函数。
那么就要在 <code>then</code> 方法中判断当前状态是否处于 <code>pending</code>，在 <code>MyPromise</code> 类中添加两个新属性 <code>successCallback</code> 和 <code>failCallback</code> 来接收 <code>then</code> 方法的成功回调函数和失败回调函数，以便于在异步任务结束后能在 <code>resolve</code> 或 <code>reject</code> 属性方法内进行调用，使 <code>then</code> 方法在 <code>Promise</code> 执行器有异步任务的情况下能正常工作。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>   <span class="token comment">// 等待</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>   <span class="token comment">// 成功</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span>     <span class="token comment">// 失败</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 传入一个执行器并立即执行（执行器的两个参数是函数）</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// promise 状态初始值</span>
    status <span class="token operator">=</span> <span class="token constant">PENDING</span>
    <span class="token comment">// promise 成功 resolve 传递的值（默认值）</span>
    value <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">// promise 失败 reject 传递的原因（默认值）</span>
    reason <span class="token operator">=</span> <span class="token keyword">undefined</span>
    
    <span class="token comment">// 成功回调</span>
    successCallback <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">// 失败回调</span>
    failCallback <span class="token operator">=</span> <span class="token keyword">undefined</span>
    
    <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为成功</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>
        <span class="token comment">// 保存 promise 成功传过来的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value 
        
        <span class="token comment">// 判断成功回调是否存在，如果存在，则调用</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为失败</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span>
        <span class="token comment">// 保存 promise 失败传过来的原因</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason 
        
        <span class="token comment">// 判断失败回调是否存在，如果存在，则调用</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 类的所有方法都是定义在类的 prototype 属性上面的</span>
    <span class="token comment">// 即类的方法是被定义在原型对象中的，此处 then 方法就是</span>
    <span class="token comment">// then 方法期望的参数是回调函数</span>
    <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断状态</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        
            <span class="token comment">// pending 等待状态</span>
            <span class="token comment">// 如果 Promsie 实例对象传入的执行器存在异步任务时</span>
            <span class="token comment">// 会开启异步任务后立即执行 then，此时状态还是处于 pending</span>
            <span class="token comment">// 将成功回调和失败回调函数通过类的属性储存起来</span>
            <span class="token comment">// 以便于异步任务结束后在 resolve 或 reject 中执行 then 的回调函数</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback <span class="token operator">=</span> successCallback
            <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback <span class="token operator">=</span> failCallback
            
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="实现-then-方法多次调用"><a href="#实现-then-方法多次调用" class="header-anchor">#</a> 实现 then 方法多次调用</h2> <p>同一个 <code>Promise</code> 实例对象的 <code>then</code> 方法是可以被多次调用的，当 <code>Promise</code> 状态变为成功或失败时，<code>then</code> 方法里面的成功或失败回调函数是要被依次调用的。其中，<code>Promise</code> 实例对象传入的执行器里面的代码有可能是同步执行也有可能是异步执行。</p> <p>如果是同步执行，执行 <code>then</code> 方法的时候 <code>Promise</code> 状态已经改变，那么执行 <code>then</code> 方法内相对应的回调函数即可。如果是异步执行，那么我们需要将多次调用 <code>then</code> 方法所触发的回调函数用数组储存起来，等待 <code>Promise</code> 执行器的异步代码执行完毕后，根据返回状态成功或失败，在 <code>resolve</code> 或 <code>reject</code> 属性方法内循环数组，依次调用（队列先进先出）回调函数即可。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
    <span class="token comment">// resolve('成功')</span>
    <span class="token comment">// reject('失败')</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>   <span class="token comment">// 等待</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>   <span class="token comment">// 成功</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span>     <span class="token comment">// 失败</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 传入一个执行器并立即执行（执行器两个参数是函数）</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// promise 状态初始值</span>
    status <span class="token operator">=</span> <span class="token constant">PENDING</span>
    <span class="token comment">// promise 成功 resolve 传递的值（默认值）</span>
    value <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">// promise 失败 reject 传递的原因（默认值）</span>
    reason <span class="token operator">=</span> <span class="token keyword">undefined</span>
    
    <span class="token comment">// 成功回调</span>
    <span class="token comment">// successCallback = undefined</span>
    <span class="token comment">// 因为多次调用 then 方法，所以用数组来存储多个回调函数</span>
    successCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 失败回调</span>
    <span class="token comment">// failCallback = undefined</span>
    failCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为成功</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>
        <span class="token comment">// 保存 promise 成功传过来的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value 
        
        <span class="token comment">// 判断成功回调是否存在，如果存在，则调用</span>
        <span class="token comment">// this.successCallback &amp;&amp; this.successCallback(this.value)</span>
        <span class="token comment">// 因为多次调用 then 方法，回调函数存储在数组中，所以需要循环依次调用（队列先进先出）</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为失败</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span>
        <span class="token comment">// 保存 promise 失败传过来的原因</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason 
        
        <span class="token comment">// 判断失败回调是否存在，如果存在，则调用</span>
        <span class="token comment">// this.failCallback &amp;&amp; this.failCallback(this.reason)</span>
        <span class="token comment">// 因为多次调用 then 方法，回调函数存储在数组中，所以需要循环依次调用（队列先进先出）</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 类的所有方法都是定义在类的 prototype 属性上面的</span>
    <span class="token comment">// 即类的方法是被定义在原型对象中的，此处 then 方法就是</span>
    <span class="token comment">// then 方法期望的参数是回调函数</span>
    <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断状态</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        
            <span class="token comment">// pending 等待状态</span>
            <span class="token comment">// 如果 Promsie 实例对象传入的执行器存在异步任务时</span>
            <span class="token comment">// 会开启异步任务后立即执行 then，此时状态还是处于 pending</span>
            <span class="token comment">// 将成功回调和失败回调函数通过类的属性储存起来</span>
            <span class="token comment">// 以便于异步任务结束后在 resolve 或 reject 中执行 then 的回调函数</span>
            
            <span class="token comment">// 多次调用 then 方法，回调函数存储到数组中</span>
            <span class="token comment">// this.successCallback = successCallback</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">)</span>
            <span class="token comment">// this.failCallback = failCallback</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">)</span>
            
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="实现-then-方法的链式调用"><a href="#实现-then-方法的链式调用" class="header-anchor">#</a> 实现 then 方法的链式调用</h2> <p><code>Promise</code> 实例对象的 <code>then</code> 方法是可以被链式调用的。要实现 <code>then</code> 方法的链式调用，<code>then</code> 方法必须返回一个 <code>Promise</code> 对象。所以我们要在 <code>then</code> 方法里创建一个新的 <code>Promise</code> 对象并返回， 还要实现将上一个 then 方法的回调函数返回值传递给下一个 <code>then</code> 方法。</p> <p>具体实现是在上一个 <code>then</code> 方法里返回的新 <code>Promise</code> 对象的执行器里执行 <code>resolve</code> 方法，<code>resolve</code> 方法会把上一个 <code>then</code> 方法的回调函数返回的值传递给新 <code>Promise</code> 对象的 <code>then</code> 方法，这样就实现了 <code>then</code> 方法的链式调用。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// setTimeout(() =&gt; {</span>
    <span class="token comment">//    resolve('成功')</span>
    <span class="token comment">// }, 2000)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
    <span class="token comment">// reject('失败')</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">100</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>   <span class="token comment">// 等待</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>   <span class="token comment">// 成功</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span>     <span class="token comment">// 失败</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 传入一个执行器并立即执行（执行器两个参数是函数）</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// promise 状态初始值</span>
    status <span class="token operator">=</span> <span class="token constant">PENDING</span>
    <span class="token comment">// promise 成功 resolve 传递的值（默认值）</span>
    value <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">// promise 失败 reject 传递的原因（默认值）</span>
    reason <span class="token operator">=</span> <span class="token keyword">undefined</span>
    
    <span class="token comment">// 成功回调</span>
    <span class="token comment">// successCallback = undefined</span>
    <span class="token comment">// 因为多次调用 then 方法，所以用数组来存储多个回调函数</span>
    successCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 失败回调</span>
    <span class="token comment">// failCallback = undefined</span>
    failCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为成功</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>
        <span class="token comment">// 保存 promise 成功传过来的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value 
        
        <span class="token comment">// 判断成功回调是否存在，如果存在，则调用</span>
        <span class="token comment">// this.successCallback &amp;&amp; this.successCallback(this.value)</span>
        <span class="token comment">// 因为多次调用 then 方法，回调函数存储在数组中，所以需要循环依次调用（队列先进先出）</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为失败</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span>
        <span class="token comment">// 保存 promise 失败传过来的原因</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason 
        
        <span class="token comment">// 判断失败回调是否存在，如果存在，则调用</span>
        <span class="token comment">// this.failCallback &amp;&amp; this.failCallback(this.reason)</span>
        <span class="token comment">// 因为多次调用 then 方法，回调函数存储在数组中，所以需要循环依次调用（队列先进先出）</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 类的所有方法都是定义在类的 prototype 属性上面的</span>
    <span class="token comment">// 即类的方法是被定义在原型对象中的，此处 then 方法就是</span>
    <span class="token comment">// then 方法期望的参数是回调函数</span>
    <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
        <span class="token comment">// 创建新的 Promise 对象作为返回值，实现链式调用 then 方法</span>
        <span class="token keyword">let</span> newPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        
            <span class="token comment">// 判断状态</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                
                <span class="token comment">// 新的 Promise 对象的执行器调用 resolve 方法，参数是上一个 then 方法的回调函数返回值</span>
                <span class="token comment">// 因为是实现 then 方法的链式调用，所以只在 fulfilled 状态处理即可</span>
                <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
                
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            
                <span class="token comment">// pending 等待状态</span>
                <span class="token comment">// 如果 Promsie 实例对象传入的执行器存在异步任务时</span>
                <span class="token comment">// 会开启异步任务后立即执行 then，此时状态还是处于 pending</span>
                <span class="token comment">// 将成功回调和失败回调函数通过类的属性储存起来</span>
                <span class="token comment">// 以便于异步任务结束后在 resolve 或 reject 中执行 then 的回调函数</span>
                
                <span class="token comment">// 多次调用 then 方法，回调函数存储到数组中</span>
                <span class="token comment">// this.successCallback = successCallback</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">)</span>
                <span class="token comment">// this.failCallback = failCallback</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">)</span>
                
            <span class="token punctuation">}</span>
            
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> newPromise
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在链式调用 <code>then</code> 方法时，可以在回调函数返回一个普通值，也可以返回一个 <code>Promise</code> 对象。</p> <p>如果 <code>then</code> 方法的成功回调函数返回的是普通值，可以直接在 <code>then</code> 方法返回的新 <code>Promise</code> 对象的执行器中直接调用 <code>resolve</code> 方法，就可以把值传递给新 <code>Promise</code> 对象接下来要调用的 <code>then</code> 方法的回调函数。</p> <p>如果 <code>then</code> 方法的成功回调函数返回的是 <code>Promise</code> 对象，则需要查看 <code>Promise</code> 对象返回的结果，再根据结果决定调用 <code>resolve</code> 方法还是 <code>reject</code> 方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// setTimeout(() =&gt; {</span>
    <span class="token comment">//    resolve('成功')</span>
    <span class="token comment">// }, 2000)</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
    <span class="token comment">// reject('失败')</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token comment">// return 100</span>
    <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'other'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>   <span class="token comment">// 等待</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>   <span class="token comment">// 成功</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span>     <span class="token comment">// 失败</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 传入一个执行器并立即执行（执行器两个参数是函数）</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// promise 状态初始值</span>
    status <span class="token operator">=</span> <span class="token constant">PENDING</span>
    <span class="token comment">// promise 成功 resolve 传递的值（默认值）</span>
    value <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">// promise 失败 reject 传递的原因（默认值）</span>
    reason <span class="token operator">=</span> <span class="token keyword">undefined</span>
    
    <span class="token comment">// 成功回调</span>
    <span class="token comment">// successCallback = undefined</span>
    <span class="token comment">// 因为多次调用 then 方法，所以用数组来存储多个回调函数</span>
    successCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 失败回调</span>
    <span class="token comment">// failCallback = undefined</span>
    failCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为成功</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>
        <span class="token comment">// 保存 promise 成功传过来的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value 
        
        <span class="token comment">// 判断成功回调是否存在，如果存在，则调用</span>
        <span class="token comment">// this.successCallback &amp;&amp; this.successCallback(this.value)</span>
        <span class="token comment">// 因为多次调用 then 方法，回调函数存储在数组中，所以需要循环依次调用（队列先进先出）</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为失败</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span>
        <span class="token comment">// 保存 promise 失败传过来的原因</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason 
        
        <span class="token comment">// 判断失败回调是否存在，如果存在，则调用</span>
        <span class="token comment">// this.failCallback &amp;&amp; this.failCallback(this.reason)</span>
        <span class="token comment">// 因为多次调用 then 方法，回调函数存储在数组中，所以需要循环依次调用（队列先进先出）</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 类的所有方法都是定义在类的 prototype 属性上面的</span>
    <span class="token comment">// 即类的方法是被定义在原型对象中的，此处 then 方法就是</span>
    <span class="token comment">// then 方法期望的参数是回调函数</span>
    <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
        <span class="token comment">// 创建新的 Promise 对象作为返回值，实现链式调用 then 方法</span>
        <span class="token keyword">let</span> newPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        
            <span class="token comment">// 判断状态</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                
                <span class="token comment">// 新的 Promise 对象的执行器调用 resolve 方法，参数是上一个 then 方法的回调函数返回值</span>
                <span class="token comment">// 因为是实现 then 方法的链式调用，所以只在 fulfilled 状态处理即可</span>
                <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                <span class="token comment">// 注释掉 resolve(x)，因为返回值有两种</span>
                <span class="token comment">// 判断 x 的值是普通值还是 Promise 对象</span>
                <span class="token comment">// 如果是普通值，直接调用 resolve</span>
                <span class="token comment">// 如果是 Promise 对象，查看 Promise 对象返回的结果</span>
                <span class="token comment">// 再根据 Promise 对象返回的结果，决定调用 resolve 还是 reject</span>
                <span class="token function">resolvePromise</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
                <span class="token comment">// ↑ 抽离为一个通用函数</span>
                
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            
                <span class="token comment">// pending 等待状态</span>
                <span class="token comment">// 如果 Promsie 实例对象传入的执行器存在异步任务时</span>
                <span class="token comment">// 会开启异步任务后立即执行 then，此时状态还是处于 pending</span>
                <span class="token comment">// 将成功回调和失败回调函数通过类的属性储存起来</span>
                <span class="token comment">// 以便于异步任务结束后在 resolve 或 reject 中执行 then 的回调函数</span>
                
                <span class="token comment">// 多次调用 then 方法，回调函数存储到数组中</span>
                <span class="token comment">// this.successCallback = successCallback</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">)</span>
                <span class="token comment">// this.failCallback = failCallback</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">)</span>
                
            <span class="token punctuation">}</span>
            
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> newPromise
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">resolvePromise</span> <span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断 x 是否是 Promise 实例</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Promise 对象</span>
        <span class="token comment">// x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span>
        <span class="token comment">// 因为 resolve 跟 reject 都是函数，且在这里是作为 then 方法的回调函数，所以可以简化为</span>
        x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 普通值</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="then-方法链式调用识别-promise-对象自返回"><a href="#then-方法链式调用识别-promise-对象自返回" class="header-anchor">#</a> then 方法链式调用识别 Promise 对象自返回</h2> <p><code>then</code> 方法回调函数可以返回 <code>Promise</code> 对象，但是有一种情况是例外，那就是在 <code>then</code> 方法回调函数里，不能返回当前 <code>then</code> 方法的 <code>Promise</code> 对象，否则程序会抛出循环调用的错误。如：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">var</span> p1 <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token comment">// 这样写会发生 Promise 对象的循环调用，会抛出错误</span>
    <span class="token keyword">return</span> p1
<span class="token punctuation">}</span><span class="token punctuation">)</span>

p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">.</span>message<span class="token punctuation">)</span>     <span class="token comment">// Chaining cycle detected for promise #&lt;Promise&gt;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>那么，下面在我们自己实现的 <code>MyPromise</code> 类实现对这个错误进行捕获并提示。</p> <p>首先我们需要判断 <code>then</code> 方法所返回的 <code>Promise</code> 对象是否是当前 <code>then</code> 方法的 <code>Promise</code> 对象，我们需要将 <code>newPromise</code> 实例对象传到 <code>resolvePromise</code> 函数去。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Mypromise</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
    
    <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建新的 Promise 对象作为返回值，实现链式调用 then 方法</span>
        <span class="token keyword">let</span> newPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        
            <span class="token comment">// 判断状态</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                
                <span class="token comment">// 只需要判断 x 跟 newPromise 是否相等</span>
                <span class="token comment">// 即可判断出回调函数返回的 promise 对象是否是当前 then 方法的 Promise 对象</span>
                <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                <span class="token comment">// 将 newPromise 对象传递到 resolvePromise 函数中做判断</span>
                <span class="token function">resolvePromise</span><span class="token punctuation">(</span>newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
                
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                
                <span class="token comment">// pending</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">)</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">)</span>
                
            <span class="token punctuation">}</span>
            
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> newPromise
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token comment">// 这样写会发生 Promise 对象的循环调用，会抛出错误</span>
    <span class="token keyword">return</span> p1
<span class="token punctuation">}</span><span class="token punctuation">)</span>

p1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">reason</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">.</span>message<span class="token punctuation">)</span>     <span class="token comment">// Chaining cycle detected for promise #&lt;Promise&gt;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>resolvePromise 函数增加对传递过来的两个参数进行相等判断。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">resolvePromise</span> <span class="token punctuation">(</span><span class="token parameter">newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断 newPromise 与 x 是否是同一个 Promise 对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newPromise <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 触发失败回调函数</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Chaining cycle detected for promise #&lt;Promise&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是，当前代码尚未可以正常运行，因为上面调用 <code>resolvePromise(newPromise, x, resolve, reject)</code> 的时候，<code>newPromise</code> 还没有被赋值，此时还是 <code>undefined</code>，我们需要在调用 <code>resolvePromise(newPromise, x, resolve, reject)</code> 函数时 <code>newPromise</code> 是被赋值完成的。</p> <p>方法就是将 <code>newPromise</code> 对象执行器所执行的 <code>resolvePromise</code> 方法变成异步任务即可，这样就可以获取到 <code>newPromise</code> 被赋值后的值。因为<strong>异步任务的回调函数会在所有同步任务完成后才会被执行</strong>，使用 <code>setTimeout</code> 改造一下即可。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// 判断状态</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 只需要判断 x 跟 newPromise 是否相等</span>
        <span class="token comment">// 即可判断出回调函数返回的 promise 对象是否是当前 then 方法的 Promise 对象</span>
        <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
        <span class="token comment">// 将 newPromise 对象传递到 resolvePromise 函数中做判断</span>
        <span class="token function">resolvePromise</span><span class="token punctuation">(</span>newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
    
<span class="token punctuation">}</span>
</code></pre></div><p>下面是增加 <code>then</code> 方法链式调用识别 <code>Promise</code> 对象自返回处理的 <code>MyPromise</code> 类完整代码。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token constant">PENDING</span> <span class="token operator">=</span> <span class="token string">'pending'</span>   <span class="token comment">// 等待</span>
<span class="token keyword">const</span> <span class="token constant">FULFILLED</span> <span class="token operator">=</span> <span class="token string">'fulfilled'</span>   <span class="token comment">// 成功</span>
<span class="token keyword">const</span> <span class="token constant">REJECTED</span> <span class="token operator">=</span> <span class="token string">'rejected'</span>     <span class="token comment">// 失败</span>

<span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span> <span class="token punctuation">(</span><span class="token parameter">executor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 传入一个执行器并立即执行（执行器两个参数是函数）</span>
        <span class="token function">executor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>resolve<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// promise 状态初始值</span>
    status <span class="token operator">=</span> <span class="token constant">PENDING</span>
    <span class="token comment">// promise 成功 resolve 传递的值（默认值）</span>
    value <span class="token operator">=</span> <span class="token keyword">undefined</span>
    <span class="token comment">// promise 失败 reject 传递的原因（默认值）</span>
    reason <span class="token operator">=</span> <span class="token keyword">undefined</span>
    
    <span class="token comment">// 成功回调</span>
    <span class="token comment">// successCallback = undefined</span>
    <span class="token comment">// 因为多次调用 then 方法，所以用数组来存储多个回调函数</span>
    successCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token comment">// 失败回调</span>
    <span class="token comment">// failCallback = undefined</span>
    failCallback <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    
    <span class="token function-variable function">resolve</span> <span class="token operator">=</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为成功</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">FULFILLED</span>
        <span class="token comment">// 保存 promise 成功传过来的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value 
        
        <span class="token comment">// 判断成功回调是否存在，如果存在，则调用</span>
        <span class="token comment">// this.successCallback &amp;&amp; this.successCallback(this.value)</span>
        <span class="token comment">// 因为多次调用 then 方法，回调函数存储在数组中，所以需要循环依次调用（队列先进先出）</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token function-variable function">reject</span> <span class="token operator">=</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果状态不是等待，阻止程序向下执行</span>
        <span class="token comment">// 因为 Promise 一旦状态改变，是不可以再改变的 </span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">!==</span> <span class="token constant">PENDING</span><span class="token punctuation">)</span> <span class="token keyword">return</span>
        <span class="token comment">// 将状态更改为失败</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token constant">REJECTED</span>
        <span class="token comment">// 保存 promise 失败传过来的原因</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>reason <span class="token operator">=</span> reason 
        
        <span class="token comment">// 判断失败回调是否存在，如果存在，则调用</span>
        <span class="token comment">// this.failCallback &amp;&amp; this.failCallback(this.reason)</span>
        <span class="token comment">// 因为多次调用 then 方法，回调函数存储在数组中，所以需要循环依次调用（队列先进先出）</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">// 类的所有方法都是定义在类的 prototype 属性上面的</span>
    <span class="token comment">// 即类的方法是被定义在原型对象中的，此处 then 方法就是</span>
    <span class="token comment">// then 方法期望的参数是回调函数</span>
    <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
        <span class="token comment">// 创建新的 Promise 对象作为返回值，实现链式调用 then 方法</span>
        <span class="token keyword">let</span> newPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        
            <span class="token comment">// 判断状态</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                
                <span class="token comment">// 异步任务，保证获取到 newPromise 对象</span>
                <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 新的 Promise 对象的执行器调用 resolve 方法，参数是上一个 then 方法的回调函数返回值</span>
                    <span class="token comment">// 因为是实现 then 方法的链式调用，所以只在 fulfilled 状态处理即可</span>
                    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                    <span class="token comment">// 注释掉 resolve(x)，因为返回值有两种</span>
                    <span class="token comment">// 判断 x 的值是普通值还是 Promise 对象</span>
                    <span class="token comment">// 如果是普通值，直接调用 resolve</span>
                    <span class="token comment">// 如果是 Promise 对象，查看 Promise 对象返回的结果</span>
                    <span class="token comment">// 再根据 Promise 对象返回的结果，决定调用 resolve 还是 reject</span>
                    <span class="token comment">// 增加判断 newPromise 跟 x 是否是同一个 Promise 对象，避免程序异常</span>
                    <span class="token function">resolvePromise</span><span class="token punctuation">(</span>newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
                
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            
                <span class="token comment">// pending 等待状态</span>
                <span class="token comment">// 如果 Promsie 实例对象传入的执行器存在异步任务时</span>
                <span class="token comment">// 会开启异步任务后立即执行 then，此时状态还是处于 pending</span>
                <span class="token comment">// 将成功回调和失败回调函数通过类的属性储存起来</span>
                <span class="token comment">// 以便于异步任务结束后在 resolve 或 reject 中执行 then 的回调函数</span>
                
                <span class="token comment">// 多次调用 then 方法，回调函数存储到数组中</span>
                <span class="token comment">// this.successCallback = successCallback</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">)</span>
                <span class="token comment">// this.failCallback = failCallback</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">)</span>
                
            <span class="token punctuation">}</span>
            
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        
        <span class="token keyword">return</span> newPromise
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">resolvePromise</span> <span class="token punctuation">(</span><span class="token parameter">newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断 newPromise 与 x 是否是同一个 Promise 对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>newPromise <span class="token operator">===</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 触发失败回调函数</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Chaining cycle detected for promise #&lt;Promise&gt;'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 判断 x 是否是 Promise 实例</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Promise 对象</span>
        <span class="token comment">// x.then(value =&gt; resolve(value), reason =&gt; reject(reason))</span>
        <span class="token comment">// 因为 resolve 跟 reject 都是函数，且在这里是作为 then 方法的回调函数，所以可以简化为</span>
        x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 普通值</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="捕获错误"><a href="#捕获错误" class="header-anchor">#</a> 捕获错误</h2> <p>使用 <code>try catch</code> 捕获错误，并使用 <code>reject</code> 方法将原因传递给下一个 <code>then</code> 方法的失败回调函数。</p> <ul><li>捕获 <code>MyPromise</code> 对象执行器抛出的错误</li> <li>捕获 <code>then</code> 方法成功回调抛出的错误</li></ul> <h2 id="将-then-方法的参数变成可选参数"><a href="#将-then-方法的参数变成可选参数" class="header-anchor">#</a> 将 then 方法的参数变成可选参数</h2> <p><code>Promise</code> 对象的 <code>then</code> 方法可以不传递参数，此时 <code>Promise</code> 对象的状态可以依次往后传递，直到传递给有回调函数的 <code>then</code> 方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// 100</span>
</code></pre></div><p>其内部处理实现类似于：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// 100</span>
</code></pre></div><p>我们可以在 <code>MyPromise</code> 类里面实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
    
    <span class="token function">then</span> <span class="token punctuation">(</span><span class="token parameter">successCallback<span class="token punctuation">,</span> failCallback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 增加 then 参数的判断，没有参数则默认设置一个函数参数</span>
        successCallback <span class="token operator">=</span> successCallback <span class="token operator">?</span> <span class="token function-variable function">successCallback</span> <span class="token operator">:</span> <span class="token parameter">value</span> <span class="token operator">=&gt;</span> value
        failCallback <span class="token operator">=</span> failCallback <span class="token operator">?</span> <span class="token function-variable function">failCallback</span> <span class="token operator">:</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> reason
        <span class="token comment">// 创建新的 Promise 对象作为返回值，实现链式调用 then 方法</span>
        <span class="token keyword">let</span> newPromise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 判断状态</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">FULFILLED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 只需要判断 x 跟 newPromise 是否相等</span>
                <span class="token comment">// 即可判断出回调函数返回的 promise 对象是否是当前 then 方法的 Promise 对象</span>
                <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token function">successCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>
                <span class="token comment">// 将 newPromise 对象传递到 resolvePromise 函数中做判断</span>
                <span class="token function">resolvePromise</span><span class="token punctuation">(</span>newPromise<span class="token punctuation">,</span> x<span class="token punctuation">,</span> resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token constant">REJECTED</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">failCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>reason<span class="token punctuation">)</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token comment">// pending</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>successCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>successCallback<span class="token punctuation">)</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>failCallback<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>failCallback<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> newPromise
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'成功'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// 成功</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'失败'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">// 失败</span>
</code></pre></div><p>【注意】<code>ES6</code> 中的 <code>Promise</code> 对象的 <code>then</code> 方法期待的参数是一个回调函数，<strong>如果该参数不是函数，则会在内部被替换为 <code>(x) =&gt; x</code>，即原样返回 ==promise 最终结果==的函数（此现象又被称为值穿透）</strong>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span>   <span class="token comment">// 1</span>
</code></pre></div><p>等同于</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">x</span> <span class="token operator">=&gt;</span> x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// 1</span>
</code></pre></div><h2 id="promise-all-方法的实现"><a href="#promise-all-方法的实现" class="header-anchor">#</a> Promise.all 方法的实现</h2> <p><code>Promise.all</code> 允许按照异步代码调用的顺序执行代码。<code>Promise.all</code> 接收一个数组作为参数，数组里面可以填入任何值，包括普通值和 <code>Promise</code> 对象，这个数组中值的顺序一定是得到结果的顺序。</p> <p><code>Promise.all</code> 的返回值也是一个 <code>Promise</code> 对象，所以也可以链式调用 <code>then</code> 方法。</p> <p><code>Promise.all</code> 有一个特点，在 <code>all</code> 方法中所有 <code>Promise</code> 对象，如果状态都是成功的，那么最后 <code>all</code> 方法也是成功的。如果有一个失败了，那么最后 <code>all</code> 方法就是失败的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token function">p1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">p2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// result -&gt; ['a', 'b', p1, p2, '3']</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>从调用方式来看，<code>all</code> 是一个静态方法。在 <code>ES6</code> 的 <code>class</code> 中，使用 <code>static</code> 定义的方法为静态方法，该方法不能被实例对象调用，只能通过类（即构造函数）来调用，且静态方法可以与动态方法重名。静态方法中的 <code>this</code> 指向的是类，不是实例对象。</p> <p>下面实现 <code>Promise.all</code> 功能：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
    
    <span class="token keyword">static</span> <span class="token function">all</span> <span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 结果数组</span>
        <span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token comment">// 考虑到数组中 Promise 存在异步操作，故用计数器判断全部执行完成返回 Promise.all 的结果</span>
        <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token number">0</span>
        
        <span class="token keyword">return</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 添加数据函数（放在 MyPromise 里面是为了能调用 resolve）</span>
            <span class="token keyword">function</span> <span class="token function">addData</span> <span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
                index <span class="token operator">++</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">===</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 循环判断数组的值是普通值还是 Promise 对象</span>
            <span class="token comment">// 如果是普通值，则直接放进结果数组</span>
            <span class="token comment">// 如果是 Promise 对象，则先去执行 Promise 对象，再把 Promise 对象执行的结果放到结果数组中</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">let</span> current <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token comment">// instanceof 简单来说就是检测原型链的</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// promise 对象</span>
                    current<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token function">addData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 普通值</span>
                    <span class="token function">addData</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> current<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="promise-race-方法的实现"><a href="#promise-race-方法的实现" class="header-anchor">#</a> Promise.race 方法的实现</h2> <p><code>Promise.race</code> 同样接收一个数组作为参数，数组里面可以填入任何值，包括普通值和 <code>Promise</code> 对象。<code>Promise.race</code> 的返回值也是一个 <code>Promise</code> 对象，所以也可以链式调用 <code>then</code> 方法。</p> <p><code>Promise.race</code> 方法的参数与 <code>Promise.all</code> 方法一样，如果参数的项不是 <code>Promise</code> 实例，会将参数转为 <code>Promise</code> 实例，再进一步处理。</p> <p><code>Promise.race</code>的特点是，<code>race</code> 方法中的所有 <code>Promise</code> 对象，只要有一个率先改变状态，无论是成功还是失败，那就是 <code>Promise.race</code> 方法返回的 <code>Promise</code> 对象的最终结果。</p> <p>下面实现 Promise.race 功能：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
    
    <span class="token keyword">static</span> <span class="token function">race</span> <span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">MyPromise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// 循环判断数组的值是普通值还是 Promise 对象</span>
            <span class="token comment">// 如果是 Promise 对象，则先去执行 Promise 对象，再把 Promise 对象执行的结果放到结果数组中</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">let</span> current <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                <span class="token comment">// instanceof 简单来说就是检测原型链的</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token keyword">instanceof</span> <span class="token class-name">MyPromise</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token comment">// promise 对象</span>
                    current<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span>reason<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token comment">// 普通值</span>
                    <span class="token function">resolve</span><span class="token punctuation">(</span>current<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="promise-resolve-方法的实现"><a href="#promise-resolve-方法的实现" class="header-anchor">#</a> Promise.resolve 方法的实现</h2> <p>在 <code>resolve</code> 方法内部，首先判断给定的参数是不是 <code>Promise</code> 对象。如果是 <code>Promise</code> 对象，则原封不动直接返回。如果不是 <code>Promise</code> 对象，则创建一个新的 <code>Promise</code> 对象，把给定的值包裹在 <code>Promise</code> 对象当中，然后返回这个 <code>Promise</code> 对象即可。</p> <p>代码实现如下：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
    
    <span class="token keyword">static</span> <span class="token function">resolve</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 如果是 Promise 对象，原封不动返回</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>value instancof MyPromise<span class="token punctuation">)</span> <span class="token keyword">return</span> value
        <span class="token comment">// 不是 Promise 对象的话，则创建并返回一个 Promise 对象</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyPromise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="finally-方法的实现"><a href="#finally-方法的实现" class="header-anchor">#</a> finally 方法的实现</h2> <ul><li>无论当前 <code>Promise</code> 对象的最终状态是成功或失败，<code>finally</code> 方法的回调函数都会被执行</li> <li>在 <code>finally</code> 方法后面，可以链式调用 <code>then</code> 方法来拿到当前这个 <code>Promise</code> 对象返回的最终结果</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
    
    <span class="token function">finally</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// callback()</span>
            <span class="token comment">// return value</span>
            <span class="token comment">// 保证 callback 中的异步任务的完成后再触发后面的 then 方法回调函数</span>
            <span class="token keyword">return</span> MyPromise<span class="token punctuation">,</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> value<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token comment">// callback()</span>
            <span class="token comment">// throw reason</span>
            <span class="token comment">// 保证 callback 中的异步任务的完成后再触发后面的 then 方法回调函数</span>
            <span class="token keyword">return</span> MyPromise<span class="token punctuation">,</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> reason <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="catch-方法的实现"><a href="#catch-方法的实现" class="header-anchor">#</a> catch 方法的实现</h2> <p><code>catch</code> 方法是用来处理当前这个 <code>Promise</code> 对象最终的状态为失败的情况的，这样 <code>then</code> 方法里面可以不传入失败回调函的数，这个失败会被 <code>catch</code> 方法捕获，从而执行 <code>catch</code> 方法内的回调函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">MyPromise</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token operator">...</span>
    
    <span class="token function">catch</span> <span class="token punctuation">(</span>failCallback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用了 then 方法，只注册了失败回调函数</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> failCallback<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">12/10/2020, 7:30:35 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/_posts/frontend/javascript/publish_subscribe_observer.html" class="prev">
        发布订阅模式和观察者模式
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/app.81246855.js" defer></script><script src="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/2.905a7cdf.js" defer></script><script src="https://cdn.jsdelivr.net/gh/jwchan1996/blog@gh-pages/assets/js/47.ac5420cb.js" defer></script>
  </body>
</html>
